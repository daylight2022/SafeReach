name: Version Management

on:
  push:
    branches: [main, master]
    paths:
      - "package.json" # 只有当 package.json 发生变化时才触发
  workflow_dispatch:

jobs:
  version-sync:
    # 当 package.json 中的版本号发生变化时，同步到后端
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # 需要获取前一个提交来比较版本变化
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Get version information
        id: version_info
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

          # 检查是否是手动触发或版本确实发生了变化
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual trigger - will sync current version"
            echo "should_sync=true" >> $GITHUB_OUTPUT
          else
            # 检查版本是否发生变化
            PREVIOUS_VERSION=$(git show HEAD~1:package.json | node -p "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).version" 2>/dev/null || echo "0.0.0")
            echo "Previous version: $PREVIOUS_VERSION"

            if [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
              echo "Version changed from $PREVIOUS_VERSION to $CURRENT_VERSION"
              echo "should_sync=true" >> $GITHUB_OUTPUT
            else
              echo "Version unchanged - skipping sync"
              echo "should_sync=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Determine update type
        id: update_type
        if: steps.version_info.outputs.should_sync == 'true'
        run: |
          CURRENT_VERSION="${{ steps.version_info.outputs.version }}"

          # 尝试获取上一个版本
          PREVIOUS_VERSION=$(git show HEAD~1:package.json | node -p "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).version" 2>/dev/null || echo "0.0.0")

          echo "Comparing versions: $PREVIOUS_VERSION -> $CURRENT_VERSION"

          # 解析版本号
          IFS='.' read -ra CURRENT_PARTS <<< "$CURRENT_VERSION"
          IFS='.' read -ra PREVIOUS_PARTS <<< "$PREVIOUS_VERSION"

          CURRENT_MAJOR=${CURRENT_PARTS[0]:-0}
          CURRENT_MINOR=${CURRENT_PARTS[1]:-0}
          CURRENT_PATCH=${CURRENT_PARTS[2]:-0}

          PREVIOUS_MAJOR=${PREVIOUS_PARTS[0]:-0}
          PREVIOUS_MINOR=${PREVIOUS_PARTS[1]:-0}
          PREVIOUS_PATCH=${PREVIOUS_PARTS[2]:-0}

          # 确定更新类型
          if [ "$CURRENT_MAJOR" -gt "$PREVIOUS_MAJOR" ]; then
            echo "update_type=major" >> $GITHUB_OUTPUT
            echo "Update type: major"
          elif [ "$CURRENT_MINOR" -gt "$PREVIOUS_MINOR" ]; then
            echo "update_type=minor" >> $GITHUB_OUTPUT
            echo "Update type: minor"
          elif [ "$CURRENT_PATCH" -gt "$PREVIOUS_PATCH" ]; then
            echo "update_type=patch" >> $GITHUB_OUTPUT
            echo "Update type: patch"
          else
            echo "update_type=patch" >> $GITHUB_OUTPUT
            echo "Update type: patch (default)"
          fi

      - name: Generate version code
        id: version_code
        if: steps.version_info.outputs.should_sync == 'true'
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          IFS='.' read -ra PARTS <<< "$VERSION"
          MAJOR=${PARTS[0]:-0}
          MINOR=${PARTS[1]:-0}
          PATCH=${PARTS[2]:-0}

          # 计算版本代码: major * 10000 + minor * 100 + patch
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          echo "code=$VERSION_CODE" >> $GITHUB_OUTPUT
          echo "Version code: $VERSION_CODE"

      - name: Generate release notes
        id: release_notes
        if: steps.version_info.outputs.should_sync == 'true'
        run: |
          # 创建临时文件来处理复杂的 commit 解析
          cat > parse_commits.sh << 'SCRIPT'
          #!/bin/bash

          # 获取最近的提交信息，过滤版本相关提交
          git log --pretty=format:"%H" --no-merges -5 | while read commit_hash; do
            # 获取 commit 的 subject 和 body
            subject=$(git log --format="%s" -n 1 $commit_hash)
            body=$(git log --format="%b" -n 1 $commit_hash)

            # 跳过版本相关的提交
            if [[ "$subject" =~ ^(version:|Version|v[0-9]) ]]; then
              continue
            fi

            # 处理 conventional commits
            if [[ "$subject" =~ ^(fix|feat|chore|docs|style|refactor|test|perf):[[:space:]]* ]]; then
              # 提取描述部分（去掉类型前缀）
              desc=$(echo "$subject" | sed 's/^[^:]*:[[:space:]]*//')
              echo "- $desc"

              # 处理 body 中的列表项
              if [ -n "$body" ]; then
                echo "$body" | while IFS= read -r line; do
                  # 匹配以 "- " 开头的行
                  if [[ "$line" =~ ^[[:space:]]*-[[:space:]]+ ]]; then
                    # 清理并格式化为子项
                    clean_item=$(echo "$line" | sed 's/^[[:space:]]*-[[:space:]]*//')
                    if [ -n "$clean_item" ]; then
                      echo "  - $clean_item"
                    fi
                  fi
                done
              fi
            else
              # 非 conventional commit，直接使用 subject
              echo "- $subject"
            fi
          done
          SCRIPT

          chmod +x parse_commits.sh
          FORMATTED_COMMITS=$(./parse_commits.sh)

          # 如果没有提交，使用默认消息
          if [ -z "$FORMATTED_COMMITS" ]; then
            FORMATTED_COMMITS="- 版本更新和bug修复"
          fi

          # 创建发布说明，确保换行格式正确
          echo "## 版本 ${{ steps.version_info.outputs.version }}" > release_notes.txt
          echo "" >> release_notes.txt
          echo "### 更新内容" >> release_notes.txt
          echo -e "$FORMATTED_COMMITS" >> release_notes.txt
          echo "" >> release_notes.txt
          echo "### 发布时间" >> release_notes.txt
          echo "$(date '+%Y-%m-%d %H:%M:%S')" >> release_notes.txt
          echo "" >> release_notes.txt
          echo "### 版本类型" >> release_notes.txt
          echo "${{ steps.update_type.outputs.update_type }} 更新" >> release_notes.txt

          echo "Release notes generated"
          echo "Generated content:"
          cat release_notes.txt

      - name: Push version to backend
        if: steps.version_info.outputs.should_sync == 'true'
        run: |
          # 读取发布说明
          RELEASE_NOTES=$(cat release_notes.txt)

          # 先登录获取 token
          echo "正在登录获取认证令牌..."
          LOGIN_RESPONSE=$(curl -s -X POST "${{ secrets.BACKEND_API_URL }}/auth/login" \
            -H "Content-Type: application/json" \
            -d "{
              \"username\": \"${{ secrets.BACKEND_ADMIN_USERNAME }}\",
              \"password\": \"${{ secrets.BACKEND_ADMIN_PASSWORD }}\"
            }")

          # 检查登录是否成功
          if [ $? -ne 0 ]; then
            echo "登录请求失败"
            exit 1
          fi

          # 提取 token
          TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.data.token // empty')
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "登录失败或无法获取 token"
            echo "登录响应: $LOGIN_RESPONSE"
            exit 1
          fi

          echo "登录成功，正在推送版本信息..."

          # 推送版本信息到后端API
          curl -X POST "${{ secrets.BACKEND_API_URL }}/versions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $TOKEN" \
            -d "{
              \"version\": \"${{ steps.version_info.outputs.version }}\",
              \"versionCode\": ${{ steps.version_code.outputs.code }},
              \"releaseNotes\": $(echo "$RELEASE_NOTES" | jq -R -s .),
              \"isPrerelease\": false
            }" || echo "Failed to push version to backend, continuing..."
